Author: Hywel
layout: post
title: "动态规划"
description: "动态规划；动态规划常用题目"
date: 星期四, 06. 十二月 2018  17:34下午
categories: "Algorithm"



---

### 基本思想：
若要解一个给定问题，我们可以解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

---
### 适用情况
1. 最优子结构性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

### 实例：
讲得再多不如分析一些常用问题，顺带描述一下解题思路。**动态规划最重要的是找到动态转移方程，将原问题拆分成子问题**

 #### 实例一（斐波那契数列（Fibonacci polynomial））：

 **运用动态规划要考虑到重叠子问题性质，将自底向上计算的解保存下来，下一个问题时直接去读取上一个问题的解，而不用重复计算**

 斐波那契数列: 后一位数等于前两位数的和 (如：0 1 1 2 3 5 8 13  ...)
 状态转移方程：f(n) = f(n-1) + f(n-2) 
 如果使用递归解法（自顶向下）：
 ```
   function fib（n）
       if n = 0 or n = 1
           return n
       return fib(n − 1) + fib（n − 2）
 ```
当 n=5时，fib(5)的计算过程如下:
```
1. fib(5)
2. fib(4) + fib(3)
3. (fib(3) + fib(2)) + (fib(2) + fib(1))
4. ((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
5. (((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
```
由上面可以看出，这种算法对于相似的子问题进行了重复计算，没有用到动态规划的重叠子结构性质，并不是一种高效的算法。实际上，该算法的运算时间是指数级增长的。 改进的方法是，我们可以通过保存已经算出的子问题的解来避免重复计算(自底向上)：
```
array map [0...n] = { 0 => 0, 1 => 1 }
fib（n）
    if（map m does not contain key n）
        m[n] := fib(n − 1) + fib（n − 2）
    return m[n]
```
将前 n个已经算出的数保存在数组map中，这样在后面的计算中可以直接应用前面的结果，从而避免了重复计算。算法的运算时间变为 O(n)

#### 实例二（最大子序列和）：
最大子序列和：求解一个序列里连续子序列的最大和。例如:{1,2,-4,5,-1,6}的最大子序列为{5,-1,6},最大子序列和为10。

网上很多都是直接给出一个动态转移方程：f(n) = max{ f(n-1)+a[i], a[i] },可能会有点迷惑。这里给出我自己的一点理解：
1. 首先，最大和子序列的特点会满足首元素不为负数，如果第一个元素为负数，完全可以去掉第一个元素。
2. f(n)并不是直接表示最大子序列和，f(n)是表示包含n这个元素的最大子序列和,也就是以n元素结尾的最大和。
3. 根据特点1，将子序列划分开几部分。当某f(i)<0时，最大子序列和只能出现在前部分或者后半部分。示例中f(2) = {1,2,-4}就是划分点。

代码实现：
```
   //动态规划，状态方程 f(i) = Max{ f(i-1) + a[i], a[i] }; f(i)表示已a[i]结尾的最大和
    public static int maxSubSequence(int[] array) {

        int length = array.length;
        int[] ContainNEleSeqSum = new int[length];
        ContainNEleSeqSum[0] = array[0];
        for (int i = 1; i < length; i++) {
            ContainNEleSeqSum[i] = Math.max(ContainNEleSeqSum[i - 1] + array[i], array[i]);
            System.out.printf("包含第%d个元素的最大序列和为："+ContainNEleSeqSum[i]+"%n",i);
        }
        //找到MaxSum中的最大值
        int maxSum = Integer.MIN_VALUE;
        for (int i = 0; i < ContainNEleSeqSum.length; i++) {
            if (ContainNEleSeqSum[i] > maxSum) {
                maxSum = ContainNEleSeqSum[i];
            }
        }
        return maxSum;
    }
```

#### 实例三（m球n层楼测临界值问题）
对这个题一直耿耿于怀，当时去腾讯面试时给的面试题，把我问懵掉了。
问题： 你有两个玻璃球，要求去实验一个100层楼的临界楼层的最小次数（临界楼层为，这层楼玻璃球没碎，上一层正好碎了）。基本思想就是先用一颗随机扔，碎了就用另一颗一层一层扔，但是怎么找到这个随机值。

代码实现(对于空间和时间需要进行优化，这里只是基本思想)：
```
    /**
     * 用m球测n层楼的临界值问题：
     * m球n层楼，b(m,n) = min{ max{ b(m-1,k-1)+1, b(m,n-k)+1 } }，其中b（1，n)=n，b(2,1)=1,1<=k<=n
     * 时间复杂度为O(n^3)
     *
     * tips：
     * 还有一个简单的解题方法：
     * 以等差数列递减扔蛋，例如：
     * 2球100层楼问题，先从15楼扔，再从29楼，42楼，，，这样（依此15，14，13，，，）
     * 取巧解法：
     * 等差数列和>=n,那就是最佳值
     * (k+1)K/2>=100 , k为正整数  ===> k=14 所以最优为扔14次
     *
     * @param eggs 总的蛋数
     * @param floors 总的楼层数
     * @return 最小次数
     */
    public static int findEgg(int eggs,int floors){
        if(floors==0){return 0;}
        if(eggs==1){return floors;}
        int[] res = new int[floors];
        for (int k=1;k<=floors;k++) {
            //取一球从随机k（0<=k<=floors）层楼扔下,结果只有两种
            //第一：球没碎，问题转移为子问题findEgg（eggs，floors-k）
            //第二：球碎了，问题转移为子问题findEgg（eggs-1，k-1）
            //取最大值，即为从k层楼扔下时的最坏次数
            res[k-1] = Math.max(findEgg(eggs, floors - k) + 1, findEgg(eggs - 1, k-1) + 1);
        }
        //取全部k楼对应的结果里的最小次数即是最优解
        int min = res[0];
        for(int resElem:res){
            if(resElem<min){min = resElem;}
        }
        return min;
    }
```

```


```